\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx,color}  
\usepackage{microtype}
\usepackage{listings}
\usepackage{longtable}
\usepackage[linkcolor=blue, colorlinks=true]{hyperref}

\pdfinfo {            
	/Title(The CMOO Development Manual)
}

\setlength{\hoffset}{0pt}
\setlength{\voffset}{0pt}
\setlength{\oddsidemargin}{0pt}
\setlength{\topmargin}{0pt}
\setlength{\headheight}{0pt}
\setlength{\headsep}{0pt}
\setlength{\textheight}{\paperheight}
\setlength{\parindent}{0cm}
\setlength{\parskip}{.2cm}
\setlength{\tabcolsep}{.2cm}
\addtolength{\textheight}{-2in}
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-2in}
\clubpenalty = 10000
\widowpenalty = 10000 
\displaywidowpenalty = 10000

\lstset{basicstyle=\small, showstringspaces=false, tabsize=4,
	numbers = left, stepnumber=5, 
	language=C}

\begin{document}
% title page
\thispagestyle{empty}
~\\~\vspace{3cm}
\begin{center}
\rule{\textwidth}{1.5pt}\vspace{8mm}
{\Huge\bf The CMOO Development Manual}\vspace{4mm}
\rule{\textwidth}{1.5pt}\vspace{10mm}
{\large Robert Lemmen}
\end{center}
\clearpage

\thispagestyle{empty}
DRAFT -- \today

Please contact Robert Lemmen $<$robertle@semistable.com$>$ for questions or
feedback.
\vspace{\stretch{1}}\\
Copyright \copyright~2008 -- 2015 Robert Lemmen $<$robertle@semistable.com$>$

This document is part of CMOO, and as such, this document is released under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.

CMOO is distributed in the hope that it will be useful, but {\em without any
waranty}; without even the implied warranty of {\em merchantability} or {\em
fitness for a particular purpose}.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with CMOO. If not, see $<$http://www.gnu.org/licenses/$>$.
\cleardoublepage

% table of contents
\tableofcontents
\cleardoublepage

% content start
\section{Introduction}\label{sec:introduction}

\subsection{MOOs}

% XXX definition, heavily steal from book, short history, why are they so cool (real virtual world)

\subsection{The Problem}

% XXX touches all interesting parts of computer engineering

\subsection{Our Goal}

% XXX fully content-agnostic, persistent, consistent, concurrent/parallel, vision: make it distributed

\section{Design}\label{sec:architecture}

\subsection{Fundamental Decisions}\label{sec:fundamental_decisions}

% XXX serializable consistency: valuable, but hard and limits scalability. consequence: interpreter may block, so interruptible tasks. interpreter may deadlock, so need to detect and roll back -> I/O

% XXX VM as interpreter

\subsection{High-Level Modules}\label{sec:hl_design}

\begin{figure}[htb]
\centering
\input{design_hl.pdf_tex}
\caption{High-Level Modules}
\end{figure}

\section{Implementation Details}\label{sec:implementation_details}

\subsection{Networking}\label{sec:networking}

\subsection{Transactional I/O}\label{sec:transactional_io}

\subsection{Task Management}\label{sec:task_mgmt}

\subsection{The Virtual Machine}\label{sec:virtual_machine}

\subsubsection{Types}\label{sec:types}

The language in CMOO is dynamically typed, in other words types are associated with values rather than with variables. So the same variable can contain a number at some point and a string a little bit later. The VM differentiates between immediate types, which can be represented in their entirety in a single stack cell, and non-immediates which require some heap storage. An example for an immediate would be a integer, a string would be a non-immediate. The follwing types are supported:

% XXX descriptions of these
\begin{description}
\item[NIL]
\item[BOOL]
\item[INT]
\item[FLOAT]
\item[STRING]
\item[OBJREF]
\end{description}

Interally all of these are represented as a 64 bit cell that contains a type tag as well as the value in case of an immediate, or a pointer to teh actual object in the case of a non-immediate. Since all pointers have the lowest bits set to 0 anyway, these are used for type tagging.

\subsubsection{Registers and Stack}\label{sec:stack}

The virtual machine is fairly simple: it has registers that hold the address of the current instruction (IP), a pointer to the top of the stack (SP), and a frame pointer (FP). Unlike a ``pure'' stack VM, elements on the stack can be addressed by position relative to FP, which makes it a little bit like a register based VM. A method can reserve space on the stack for this use, which we will call ``locals''. Note that a stack cell can contain values accessible by the code, but also VM-internal information like instruction addresses or frame pointers. These are always hidden from the code executed by the VM.

So in a method call with two arguments passed in, FP will point to the first argument, and SP to the last element on the stack, the second argument. In the visualisation below, the horizontal lines show the boundaries of the call frames on the stack:

\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{3cm}}
argument 1 & $\leftarrow$ SP \\
argument 0 & $\leftarrow$ FP \\
\cline{1-1}
\ldots & \\
\end{tabular}
\end{table}

Note that in a method with only one argument, SP and FP will initially point to the same stack element, and in a method with nor aguments FP will initially point to an element beyond the stack! The number of arguments provided can be calculated using SP and FP, the method code is expected to assert that this is the expected number first. Additionally, the method can reserve a number of ``locals'' on the stack for use, these are initialized to NIL. Since most methods will do both, this is done by a combined opcode \verb|ARGS_LOCALS|. So assuming the two arguments, and one local, the stack would then look as follows:

\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{3cm}}
local 0 & $\leftarrow$ SP \\
argument 1 \\ 
argument 0 & $\leftarrow$ FP \\
\cline{1-1}
\ldots & \\
\end{tabular}
\end{table}

The stack can also be used in a more dynamic fashion using \verb|PUSH| and \verb|POP|, and even these values can be addressed relative to FP, although that is typically difficult to realise in code. These values are called ``intermediates''. So after a \verb|PUSH|, the stack would look as follows:

\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{3cm}}
intermediate 0 & $\leftarrow$ SP \\
local 0    \\    
argument 1 \\
argument 0 & $\leftarrow$ FP \\ 
\cline{1-1}
\ldots & \\
\end{tabular}
\end{table}

When calling another method, the caller has to pu the callee objref, the callee method name and all arguments on the stack. For example if we were to do that with \verb|PUSH|, the stack would look like this just before the call:

\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{3cm}}
argument 0 & $\leftarrow$ SP \\
method name \\
callee objref \\
intermediate 0 \\
local 0    \\    
argument 1 \\
argument 0 & $\leftarrow$ FP \\ 
\cline{1-1}
\ldots & \\
\end{tabular}
\end{table}

The caller will then issue a \verb|CALL| opcoode supplying the number of arguments, which will locate the object and method, and overwrite the corresponding slots with information it needs for the return: the IP when called and the previous FP:

\begin{table}[h]
\centering
\begin{tabular}{|p{3cm}|p{3cm}}
argument 0 & $\leftarrow$ SP, FP \\
\cline{1-1}
return address \\
previous FP \\
intermediate 0 \\
local 0    \\    
argument 1 \\
argument 0 \\
\cline{1-1}
\ldots & \\
\end{tabular}
\end{table}

% XXX returning 

\subsubsection{Opcodes}\label{sec:opcodes}

the VM machine code is a sequence of one-octet opcodes followed by a variable number and length of arguments. Typical types of the arguments are unsigned 8bit values that denote a local relative to FP, signed 4-byte integers that are used e.g. as relative addresses, and serializations of actual values.

\paragraph{NOOP}
\paragraph{HALT}
\paragraph{DEBUGI}
\paragraph{DEBUGR}
\paragraph{MOV}
\paragraph{PUSH}
\paragraph{POP}
\paragraph{CALL}
\paragraph{RETURN}
\paragraph{ARGS\_LOCALS}
\paragraph{CLEAR}
\paragraph{TRUE}
\paragraph{LOAD\_INT}
\paragraph{LOAD\_FLOAT}
\paragraph{TYPE}
\paragraph{LOGICAL\_AND}
\paragraph{LOGICAL\_OR}
\paragraph{LOGICAL\_NOT}
\paragraph{EQ}
\paragraph{LE}
\paragraph{LT}
\paragraph{ADD}
\paragraph{SUB}
\paragraph{MUL}
\paragraph{DIV}
\paragraph{MOD}
\paragraph{JUMP}
\paragraph{JUMP\_IF}
\paragraph{JUMP\_EQ}
\paragraph{JUMP\_NE}
\paragraph{JUMP\_LE}
\paragraph{JUMP\_LT}

\subsection{Locking}\label{sec:locking}

\subsection{Persistence}\label{sec:persistence}

\end{document}
