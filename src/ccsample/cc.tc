%option reentrant

%decls %{

#include <stdbool.h>

#include "types.h"

#define OP_AND  0
#define OP_OR   1

typedef union
{
	int		int_value;
	float	float_value;

} eval_value;

%}

%{
#include "cc_ast.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

%}

%node ast_node %abstract %typedef = {
}

// XXX many of these do not need to be ast_nodes, only really statements and further in...
%node list_entry ast_node = {
    ast_node *entry;
    list_entry *prev;
}

%node object_def ast_node = {
	char *name;
	bool exported;
	list_entry *globals;
	list_entry *slots;
}

%node global ast_node = {
	char *name;
	ast_node *value;
}

%node slot ast_node = {
	char *name;
	list_entry *arguments;
    block *body;
}

%node argument ast_node = {
	char *name;
}

%node statement ast_node %abstract %typedef = {
}

%node block statement = {
    list_entry *statements;
}

%node var_decl statement = {
    char *name;
    expression *init_expr;
}

%node return_stmt statement = {
    expression *ret_expr;
}

%node expression ast_node %abstract %typedef = {
}

%node literal expression = {
    val value;
}

%node this_expr expression = {
}

%node binary_expr expression = {
    expression *left;
    expression *right;
    int op;
}

%operation void dump(ast_node *n, int d, bool first)

dump(list_entry) {
    if (n->prev) {
        dump((ast_node*)n->prev, d, false);
        dump(n->entry, d, false);
    }
    else {
        dump(n->entry, d, true);
    }
}

dump(object_def) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("# %s%sObject %s {\n", 
        indent,
        n->exported ? "Exported " : "",
        n->name);
    dump((ast_node*)n->globals, d+1, false);
    dump((ast_node*)n->slots, d+1, false);
    printf("# %s}", indent);
}

dump(global) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("# %sGlobal %s = ", 
        indent, 
        n->name);
    dump((ast_node*)n->value, d, false);
    printf(";\n");
}

dump(slot) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("# %sSlot %s(", indent, n->name);
    dump((ast_node*)n->arguments, d, false);
    printf(") ");
    dump((ast_node*)n->body, d, false);
}

dump(argument) {
    printf("%s%s", first ? "" : ", ", n->name);
}

dump(block) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("{\n");
    if (n->statements) {
        dump((ast_node*)n->statements, d+1, false);
    }
    printf("# %s}\n", indent);
}

dump(var_decl) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("# %sVar %s = ", indent, n->name);
    dump((ast_node*)n->init_expr, d, false);
    printf(";\n");
}

dump(return_stmt) {
    char *indent = alloca(d*2+1);
    memset(indent, ' ', d*2);
    indent[d*2] = '\0';
    printf("# %sreturn ", indent);
    dump((ast_node*)n->ret_expr, d, false);
    printf(";\n");
}

dump(literal) {
    char *tval = val_print(n->value);
    printf("%s", tval);
    free(tval);
}

dump(this_expr) {
    printf("This");
}

dump(binary_expr) {
    dump(n->left, d, false);
    switch (n->op) {
        case OP_AND:
            printf(" AND ");
            break;
        case OP_OR:
            printf(" OR ");
            break;
        default:
            printf(" ?? ");
    }
    dump(n->right, d, false);
}

%end %{

char *yycurrfilename(YYNODESTATE *state) {
    return "";
}

long yycurrlinenum(YYNODESTATE *state) {
    return 0;
}

void yynodefailed(YYNODESTATE *state) {
	fprintf(stderr, "virtual memory exhausted\n");
	exit(1);
}
 
%}
